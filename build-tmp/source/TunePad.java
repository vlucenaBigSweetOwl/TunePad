/* autogenerated by Processing revision 1277 on 2021-11-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import ddf.minim.spi.*;
import ddf.minim.ugens.*;
import java.util.*;
import processing.awt.*;
import processing.javafx.*;
import uibooster.*;
import uibooster.model.*;
import uibooster.components.*;
import javax.sound.midi.*;
import java.awt.*;
import javax.swing.*;
import javax.swing.UIManager;
import javax.swing.SwingUtilities;
import uibooster.*;
import uibooster.model.*;
import javax.sound.midi.MidiDevice;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TunePad extends PApplet {





//import themidibus.*;







//import uk.co.xfactorylibrarians.coremidi4j.*;

// machine learning leading questions?


int LOAD_SONG = 1;
int EDIT = 2;
int LOAD_SAVE = 8;
int SAVE = 9;
int EXIT = 10;
int state = LOAD_SONG;

final int ARROW = 1;
// left on note: move left on edge of note: change length left on nothing: box select?
// right 
final int TEMPO = 2;
final int PEN = 3;
final int TAP = 4;
final int SECTION = 7;
int tool = PEN;

boolean[] quan = new boolean[10];

Minim minim;
FilePlayer song2;
AudioSample sample;
AudioInput input;
AudioOutput out;
TickRate rate;
float[] sig;
int volume = -15;

MyMenuBar menu;
UiBooster uib = new UiBooster(
    UiBoosterOptions.Theme.DARK_THEME
);;
Synthesizer midiSynth;

int playBackInd = 0;
float playBackRate = 1.0f;

float offBase = -170;
float off = -170;
float zoom = 69;
float zoomSpeed = 1.10f;
int zoomTotal = 0;
int seekTotal = 0;
int rollZoom = 36;
int rollMid = 60;
float waveTrans = 255;

TreeSet<Integer> tempoTaps = new TreeSet<Integer>();
float lastTap = -1;
float startTime;
float tempo;
int tgate1 = -1;
float tgate1s = -1;
int tgate2 = -1;
float tgate2s = -1;
int tempoDiv = 2;
boolean tempoSet = false;


ArrayList<Track> tracks = new ArrayList<Track>();
int trackInd = 0;


String fileName;
String saveName;

int lastS = 0;

Note chosen;

int playDelayStart = -1;
int playDelayLast = -1;

javax.sound.midi.Instrument[] inlist;
String[] inlistNames;
MidiChannel[] channels;

 public void setup(){
	println("hi");
	try{
		midiSynth = MidiSystem.getSynthesizer();
		midiSynth.open();
		channels = midiSynth.getChannels();
		inlist = midiSynth.getAvailableInstruments();
		inlistNames = new String[inlist.length];
		for(int i = 0; i < inlist.length; i++){
			midiSynth.loadInstrument(inlist[i]);
			inlistNames[i] = inlist[i].getName();
			//println(inlistNames[i]);
		}
	} catch(Exception e){}
	

	menu = new MyMenuBar((PSurfaceAWT)surface,"Test",100,100);
	/* size commented out by preprocessor */;
	//surface.setResizable(true);
	//fullScreen();
	mouseDist = width/20;
	
	minim = new Minim(this);

	
	colorMode(HSB);
	startSongPick();

	println("lo");
}

 public int s(){
	return (int)((song2.position()+off)/1000.0f*sample.sampleRate());
}

 public int step(){
	return (int)(sig.length*1.0f/width / zoom);
}

 public void draw(){
	background(0);
	if(state == EDIT){

		zoom = zoom * pow(zoomSpeed,zoomTotal);
		off = offBase * playBackRate;
		playBackRate = pow(2,(1/12.0f) * playBackInd);
		rate.value.setLastValue(playBackRate);
		int s = s();
		int step = (int)(sig.length*1.0f/width / zoom);

		textSize(30);
		textAlign(LEFT,CENTER);
		fill(255);
		text(playBackInd + " cent(s)",50,30);
		String toolString =  "???";
		if(tool==ARROW){toolString="ARROW";}
		if(tool==TEMPO){toolString="TEMPO";}
		if(tool==PEN){toolString="PEN";}
		if(tool==TAP){toolString="TAP";}
		if(tool==SECTION){toolString="SECTION";}
		text("Tool: " + toolString,width - 200,30);
		if(quan[tool]){
			text("Quantize: ON",width - 200,60);
		} else {
			text("Quantize: OFF",width - 200,60);
		}
		

		translate(width/2,0);

		drawWaveForm(s,step);

		stroke(0,0,255);
		line(0,0,0,height);
		
		for(float t: tempoTaps){
			float x = (t-s)/step;
			stroke(255,0,255,20);
			line(x,0,x,height);
		}
		for(int i = 0; i < rollZoom+1; i++){
			float y = i*(height*1.0f/rollZoom);
			stroke(255,0,255,100);
			line(-width,y,width,y);
		}
		for(Track t: tracks){
			t.display(s,step);
		}

		
		if(tgate1 != -1 && tgate2 != -1){
			tempoSet = true;
			int beatDif = tgate2 - tgate1;
			float sDif = tgate2s - tgate1s;
			tempo = sDif / beatDif;
			startTime = tgate1s;
			startTime %= tempo;
		}
		if(tempoTaps.size() > 5){
			tempoSet = true;
		}

		if(tempoSet){
			float t = startTime;
			int count = 0;
			float x = (t-s)/step;
			while(x < -width/2){
				t+= tempo/tempoDiv;
				count++;
				x = (t-s)/step;
			}
			while(x < width/2){
				stroke(255,0,255,40);
				if(count%tempoDiv == 0){
					stroke(255,0,255,100);
				}
				line(x,0,x,height);
				t+= tempo/tempoDiv;
				count++;
				x = (t-s)/step;
			}
		}
		if(song2.isPlaying()){
			checkNote(s,lastS);
		} else if(playDelayStart != -1){
			int millis = millis();
			int flastS = (int)((playDelayLast*1.0f - playDelayStart + off)*sample.sampleRate()/1000 - getMIDIoff());
			int fs = (int)((millis*1.0f - playDelayStart + off)*sample.sampleRate()/1000 - getMIDIoff());
			
			checkNote(fs,flastS);
			playDelayLast = millis;
			if(fs > off*sample.sampleRate()/1000){
				song2.loop();
				playDelayStart = -1;
				playDelayLast = -1;
			}
		}


		


		if(s < lastS){
			lastTap = -1;
		}
		lastS = s;
		
		holdTimerUpdate();
		drawTrackPicker();

	} else if (state == LOAD_SONG){
		//background(0);
		//test();
	} else if (state == LOAD_SAVE){

	} else if (state == SAVE){

	} else if (state == EXIT){

	}

	if(!focused){
		fill(30,50,0,150);
		rect(-1000,-1000,10000,10000);
	}
}

 public void drawWaveForm(int s, int step){
	strokeWeight(1);
	for(int i = -width/2; i < width/2; i+=2){
		int place = constrain(s + step*i,0,sig.length-1);

		float max = 0;
		float min = 0;
		
		int samps = (step*2)/10 ;
		if(samps <= 0){
			samps = 1;
		}

		place += (samps - place%samps)%samps;
		for(int j = 0; j < step*2; j+=samps){
			if(place + j >= sig.length || sig.length < 0){
				break;
			}
			max = max(max,sig[place + j]);
			min = min(min,sig[place + j]);
		}

		noStroke();
		fill(255,waveTrans);
		rect(i,height/2 + min*(height/4),2,max*(height/4) - min*(height/4));
		
	}
}

 public void exit(){
	midiSynth.close();
	try{
		minim.stop();
	}catch(Exception e){}
	
	if(state != EDIT){
		exitActual();
	}
	state = EXIT; 
	uib.showConfirmDialog(
        "Would you like to save?",
        "Exiting",
        () -> saveFile(),
        () -> exitActual());
	
}


 public int quanX(int x){
	int step = step();
	int time = s() + (x-width/2)*step;
	int off = (int)((time - startTime + (tempo/tempoDiv)/2 )%(tempo/tempoDiv) - (tempo/tempoDiv)/2);
	x -= off/step;
	return x;
}

 public int XtoS(int x){
	int time = s() + (x-width/2)*step();
	return time;
}



 public void checkNote(float s, float lastS){
	for(Track t: tracks){
		if(t.notes.size() <= 0){continue;}
		
		SortedSet<Note> window = (SortedSet<Note>)(SortedSet<?>)t.getWindow(s+getMIDIoff(),lastS+getMIDIoff(),STOPS);

		for(Note n: window){
			channels[t.index].noteOff(n.pitch+playBackInd,t.volume);
		}

		window = (SortedSet<Note>)(SortedSet<?>)t.getWindow(s+getMIDIoff(), lastS+getMIDIoff(),START);

		for(Note n: window){
			channels[t.index].noteOn(n.pitch+playBackInd,t.volume);
		}
	}
}

 public int getMIDIoff(){
	return (int)(sample.sampleRate()*0.27f*playBackRate);
}


int y = 70;
int w = 200;
int h = 40;
 public void drawTrackPicker(){
	resetMatrix();
	int i = 0;
	for(Track t: tracks){
		strokeWeight(3);
		if(t.index == trackInd){
			stroke(255);
			fill(t.hue,155,255,200);
			rect(0,y + i*h,w+20,h);
			fill(255);
		} else {
			stroke(255,150);
			fill(t.hue,155,255,100);
			rect(0,y + i*h,w,h);
			fill(255,150);
		}
		textAlign(LEFT,CENTER);
		text(t.name,30,y + (i+.5f)*h);
		i++;
	}
	textAlign(CENTER,CENTER);
	fill(255,0,255,200);
	text("+",w/2,y+(i+.5f)*h);
}

 public boolean checkTrackSelector(){
	if(mouseX < w){
		int ind = (mouseY - y)/h;
		if(ind < tracks.size()){
			trackInd = ind;
			return true;
		} else if (ind == tracks.size()){
			newTrack();
			return true;
		}
		
	}
	return false;
}


 public void newTrack(){
	String name = uib.showTextInputDialog("Track Name:");
	if(name == null || name.equals("")){
		tracks.add(new Track(tracks.size()));
	} else {
		tracks.add(new Track(name,tracks.size()));
	}
	trackInd = tracks.size()-1;
}

 public void deleteTrack(){
	tracks.remove(trackInd);
	if(trackInd == tracks.size()){
		trackInd--;
	}
}

boolean leftHeld, rightHeld, shiftHeld, ctrlHeld, altHeld, qHeld, lmHeld, rmHeld;
int rmTimer, lmTimer, qTimer;
int leftTime, rightTime;
int mouseDist;
int hold = 10;
int lastPitch;
boolean metafocused = false;
int pressX,pressY;

 public void mousePressed(){
	if(!metafocused){
		metafocused = true;
		return;
	}
	if(state != EDIT){
		return;
	}
	if(checkTrackSelector()){
		return;
	}

	if(mouseButton == LEFT){
		lmHeld = true;
	} else if(mouseButton == RIGHT){
		rmHeld = true;
	}
	pressX = mouseX;
	pressY = mouseY;
	if(tool == PEN){
		int row = (int)((height - mouseY)/(height*1.0f/rollZoom)) + 1;
		int pitch = rollMid - (rollZoom/2) + row;
		lastPitch = pitch;
		Track t = tracks.get(trackInd);
		channels[trackInd].noteOn(pitch+playBackInd,t.volume);
		if(mouseButton == LEFT){
			chosen = checkChosen();
			if(chosen != null){
				chosen.track.removeNote(chosen);
				chosen = null;
				lmHeld = false;
			}
		}
	}

	/*
	//TODO
	chosen = checkChosen();
	if(chosen != null){
		noteHold = true;
	}
	*/
}

 public void mouseReleased(){
	if(state != EDIT){
		return;
	}
	int s = s();
	int step = step();

	if(tool == TAP){
		if(lmTimer > hold){
			tracks.get(trackInd).addTapX(mouseX,quan[tool]);
		}
	}
	if(tool == TEMPO){
		if(lmHeld){
			tgate1 = (int)((XtoS(mouseX) - startTime + (tempo*.5f)) / tempo);
			tgate1s = XtoS(mouseX);
		} else if(rmHeld){
			tgate2 = (int)((XtoS(mouseX) - startTime + (tempo*.5f)) / tempo);
			tgate2s = XtoS(mouseX);
		}
		
	}
	if(tool == PEN){
		int row = (int)((height - mouseY)/(height*1.0f/rollZoom)) + 1;
		int pitch = rollMid - (rollZoom/2) + row;
		if(lmHeld){
			if(lmTimer > hold){
				//TODO
				if(chosen.length < 0){
					chosen.track.notes.remove(chosen);
					chosen = null;
				}
				if(quan[PEN]){
					float off = (chosen.length + (tempo/tempoDiv)/2)%(tempo/tempoDiv)-(tempo/tempoDiv)/2;
					int length = (int)(chosen.length - off);
					
					if(length <= 0){
						chosen.track.removeNote(chosen);
					} else {
						chosen.track.setNoteLength(chosen,(int)(tempo/tempoDiv));
					}
				}
			} else {
				tracks.get(trackInd).addNote(XtoS(mouseX),pitch,-1, quan[PEN]);
				// TODO: midi volume
			}
		}

		Track t = tracks.get(trackInd);
		channels[trackInd].noteOff(lastPitch,t.volume);
		channels[trackInd].noteOff(pitch,t.volume);
	}
	
	//TODO
	if(false){
		chosen.track.notes.remove(chosen);
		chosen.reverseDim(s,step,true);
		chosen.track.notes.add(chosen);
	}

	if(mouseButton == LEFT){
		lmHeld = false;
	} else if(mouseButton == RIGHT){
		rmHeld = false;
	}
	rmTimer = 0;
	lmTimer = 0;
	qTimer = 0;
}

 public void holdTimerUpdate(){
	resetMatrix();
	if(!focused){
		metafocused = false;
	}
	if(rmHeld){
		rmTimer++;
	}
	if(lmHeld){
		lmTimer++;
	}
	if(qHeld){
		qTimer++;
	}

	if(tool == PEN && !song2.isPlaying() && (height/4) < mouseY && mouseY < (height*3/4)){
		waveTrans = 100;
	} else {
		waveTrans = 255;
	}
	

	if(tool == PEN && lmTimer == hold){
		int row = (int)((height - pressY)/(height*1.0f/rollZoom)) + 1;
		int pitch = rollMid - (rollZoom/2) + row;
		chosen = tracks.get(trackInd).addNoteX(pressX,pitch,0, quan[PEN]);
	}
	if(lmTimer > hold){
		if(tool == TAP){
			stroke(tracks.get(trackInd).hue,255,255);
			int x = mouseX;
			if(quan[TAP]){
				x = quanX(x);
			}
			line(x,0,x,height);
		} else if (tool == PEN){
			chosen.length = XtoS(mouseX) - chosen.time;
		} else if(tool == TEMPO){
			stroke(150,20,255,150);
			int x = mouseX;
			line(x,0,x,height);
		}
	}

	if(rmTimer > hold){
		if(tool == PEN){
			int row = (int)((height - mouseY)/(height*1.0f/rollZoom)) + 1;
			int pitch = rollMid - (rollZoom/2) + row;
			if(pitch != lastPitch){
				Track t = tracks.get(trackInd);
				channels[trackInd].noteOff(lastPitch+playBackInd,t.volume);
				channels[trackInd].noteOn(pitch+playBackInd,t.volume);
				lastPitch = pitch;
			}
		} else if(tool == TEMPO){
			stroke(150,20,255,150);
			int x = mouseX;
			line(x,0,x,height);
		}
	}

	if(leftHeld){
		if(song2.isPlaying()){
			song2.pause();
			for(MidiChannel c: channels){
				c.allNotesOff();
			}
		}
		song2.skip((int)(-leftTime*3 *(60/frameRate)));
		leftTime++;
	} else if(rightHeld){
		song2.skip((int)(rightTime*3 *(60/frameRate)));
		rightTime++;
	}

	if(seekTotal != 0){
		song2.skip((int)(seekTotal*step()/2));
	}

	zoomTotal = 0;
	seekTotal = 0;
}

 public Note checkChosen(){
	for(Note n: tracks.get(trackInd).notes){
		if(n.touchingPoint(mouseX - width/2,mouseY,s(),step())){
			return n;
		}
	}
	return null;
}

 public void mouseWheel(MouseEvent event) {
	if(shiftHeld){
		if(ctrlHeld){
			rollZoom += event.getCount();
			rollZoom = constrain(rollZoom,5,87);
			rollMid = constrain(rollMid,21+(rollZoom/2),108-(rollZoom/2));
		} else {
			seekTotal += event.getCount();
		}
	} else if(ctrlHeld){
		rollMid += event.getCount();
		rollMid = constrain(rollMid,21+(rollZoom/2),108-(rollZoom/2));
	} else {
		zoomTotal += event.getCount();
	}
}

 public void keyPressed(){
	if(state != EDIT){
		return;
	}
	key = Character.toLowerCase(key);
	int s = s();
	if(key == '.'){
		println(frameRate + " " + zoom);
	}
	if(key == 'q'){
		qHeld = true;
	}
	if(key == 'n'){
		tempoTaps.clear();
		lastTap = -1;
		startTime = 0;
		tempo = 0;
	}
	if(key == 't' || key == 'y'){
		if(tool == TAP){
			tracks.get(trackInd).addTap(s(),quan[tool]);
		}
		if(tool == TEMPO){
			if(key == 't'){
				tgate1 = (int)((s - startTime + (tempo*.5f)) / tempo);
				tgate1s = s;
			} else {
				tgate2 = (int)((s - startTime + (tempo*.5f)) / tempo);
				tgate2s = s;
			}
		}
		
	}
	if(key == 'u' && tool == TEMPO){
		if(lastTap != -1){
			int size = tempoTaps.size();
			float dist = s - lastTap;
			if(tempoTaps.size() < 5 || dist < tempo*2){
				tempo = (tempo * size + dist) / (size + 1);
				float start = s % tempo;
				
				if(start > tempo/2){
					start -= tempo;
				}
				startTime = (startTime + start) / 2.0f;
			}
			//startTime = (startTime * size + start) / (size + 1);
		}
		tempoTaps.add(s);
		lastTap = s;
	}
	if(key == 'x'){
		if(tool == TEMPO){
			tgate1 = -1;
			tgate1s = -1;
			tgate2 = -1;
			tgate2s = -1;
			tempoTaps.clear();
			lastTap = -1;
			tempoSet = false;
		} if (tool == PEN){
			tracks.get(trackInd).clearNotes();
		} if (tool == TAP){
			tracks.get(trackInd).clearTaps();
		}
	}
	if(key == 's'){
		if(!song2.isPlaying()){
			playBackInd = 0;
		}
		song2.pause();
		for(MidiChannel c: channels){
			c.allNotesOff();
		}
	} else if(key == 'd'){
		if(song2.isPlaying()){
			playBackInd++;
		} else {
			if(song2.position() <= 0){
				song2.cue(0);
				playDelayStart = millis();
				playDelayLast = playDelayStart;
			} else {
				song2.loop();
			}
		}
	} else if(key == 'a'){
		if(song2.isPlaying()){
			playBackInd--;
		} else {
			playBackInd--;
		}
	}
	if(keyCode == LEFT && !leftHeld){
		leftHeld = true;
		leftTime = 0;
	}
	if(keyCode == RIGHT && !rightHeld){
		rightHeld = true;
		rightTime = 0;
	}
	if(keyCode == SHIFT){
		shiftHeld = true;
	}
	if(keyCode == CONTROL){
		ctrlHeld = true;
	}
	if(keyCode == ALT){
		altHeld = true;
	}

	int num = key - '0';
	if(num >= 0 && num <= 9){
		tool = num;
	}

	if(key == 's' && shiftHeld){
		startSaveFile();
	}
}

 public void keyReleased(){
	if(state != EDIT){
		return;
	}
	key = Character.toLowerCase(key);
	if(lmTimer < hold){
		//SortedSet<Integer> window = (SortedSet<Integer>)tracks.get(trackInd).getWindowX(mouseX - mouseDist, mouseX + mouseDist,TAP);

	}

	if(keyCode == LEFT){
		leftHeld = false;
		leftTime = 0;
	}
	if(keyCode == RIGHT){
		rightHeld = false;
		rightTime = 0;
	}
	if(keyCode == SHIFT){
		shiftHeld = false;
	}
	if(keyCode == CONTROL){
		ctrlHeld = false;
	}
	if(keyCode == ALT){
		altHeld = false;
	}
	if(key == 'q'){
		qHeld = true;
		quan[tool] = !quan[tool];
	}

}








class MyMenuBar {
	JFrame frame;
	
	MyMenuBar(PSurfaceAWT surface, String name, int width, int height) {
		System.setProperty("apple.laf.useScreenMenuBar", "true");
		try{
			//UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		}catch(Exception e){println("nope");}


		frame = (JFrame)((processing.awt.PSurfaceAWT.SmoothCanvas)surface.getNative()).getFrame();
		frame.setTitle(name);

		//SwingUtilities.updateComponentTreeUI(frame);
		//frame.pack();

		// Creates a menubar for a JFrame
		JMenuBar menuBar = new JMenuBar();
		// Add the menubar to the frame
		frame.setJMenuBar(menuBar);
		
		// Define and add two drop down menu to the menubar
		JMenu filem = new JMenu("File");
		JMenu trackm = new JMenu("Tracks");
		JMenu controlm = new JMenu("Control");
		JMenu helpm = new JMenu("Help");

		menuBar.add(filem);
		menuBar.add(trackm);
		menuBar.add(controlm);
		menuBar.add(helpm);
		
		// Create and add simple menu item to one of the drop down menu
		JMenuItem itemSongLoad = new JMenuItem("Open New Song");
		JMenuItem itemRecent = new JMenuItem("Open Recent");
		JMenuItem itemLoad = new JMenuItem("Load Pad");
		JMenuItem itemSave = new JMenuItem("Save Pad");
		JMenuItem itemSaveAs = new JMenuItem("Save As");
		JMenuItem itemExit = new JMenuItem("Exit");

		filem.add(itemSongLoad);
		filem.add(itemRecent);
		filem.addSeparator();
		filem.add(itemLoad);
		filem.add(itemSave);
		filem.add(itemSaveAs);
		filem.addSeparator();
		filem.add(itemExit);
		
		// Add a listener to the New menu item. actionPerformed() method will
		// invoked, if user triggred this menu item
		
		itemSongLoad.addActionListener(
			(new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					startSongPick();
				}
			})
		);

		itemLoad.addActionListener(
			(new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					startLoadFile();
				}
			})
		);


		itemSave.addActionListener(
			(new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					saveFile();
				}
			})
		);

		itemSaveAs.addActionListener(
			(new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					startSaveFile();
				}
			})
		);
		
		itemExit.addActionListener(
			(new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					exit();
				}
			})
		);
		
		JMenuItem itemSelectTrack = new JMenuItem("Select Track");
		JMenuItem itemNewTrack = new JMenuItem("New Track");
		JMenuItem itemDeleteTrack = new JMenuItem("Delete Track");
		JMenuItem itemTrackName = new JMenuItem("Set Track Name");
		JMenuItem itemTrackInstr = new JMenuItem("Set Track Instrument");
		JMenuItem itemTrackColor = new JMenuItem("Set Track Color");
		//MenuItem itemRecent = new MenuItem("Open Recent");

		trackm.add(itemSelectTrack);
		trackm.add(itemNewTrack);
		trackm.add(itemDeleteTrack);
		trackm.addSeparator();
		trackm.add(itemTrackName);
		trackm.add(itemTrackInstr);
		trackm.add(itemTrackColor);

		itemSelectTrack.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					ArrayList<String> list = new ArrayList<String>();
					for(Track t: tracks){
						list.add(t.name);
					}
					String selection = uib.showSelectionDialog(
						"Select a Track",
						"Tracks",
						list);
					for(int i = 0; i < tracks.size(); i++){
						if(tracks.get(i).name.equals(selection)){
							trackInd = i;
							break;
						}
					}
				}}));

		itemNewTrack.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					newTrack();
				}}));

		itemDeleteTrack.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					deleteTrack();
				}}));

		itemTrackName.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					String name = uib.showTextInputDialog("Track Name:");
					if(name != null){
						tracks.get(trackInd).name = name;
					}
				}}));

		itemTrackInstr.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					String selection = uib.showSelectionDialog(
						"Pick and Instrument ...",
						"Track Instrument",
						inlistNames);

					int i = Arrays.asList(inlistNames).indexOf(selection);
					if(i != -1){
						tracks.get(trackInd).setInstrument(i);
					}
				}}));

		itemTrackColor.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					Color col = uib.showColorPicker("Pick a color for " +tracks.get(trackInd).name, "Pick Track Color");
					colorMode(RGB);
					float hue = hue(color(col.getRed(),col.getGreen(),col.getBlue()));
					colorMode(HSB);
					tracks.get(trackInd).hue = hue;
				}}));

		JMenuItem itemVolume = new JMenuItem("Volume");
		JMenuItem itemTempoDiv = new JMenuItem("Beat Division");
		//MenuItem itemRecent = new MenuItem("Open Recent");

		controlm.add(itemVolume);
		controlm.add(itemTempoDiv);

		itemTempoDiv.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					Integer divs = uib.showSlider("Split each tempo into how many parts?", "Beat Division",
						1, 16, tempoDiv, 2, 1);

					tempoDiv = divs;

				}}));

		itemVolume.addActionListener((new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent a) {
					
					FormBuilder fb = uib.createForm("Test");
			        fb.addSlider("Volume", -30, 5, volume, 5, 1).setID("Vol");
			        for(Track t: tracks){
			        	fb.addSlider(t.name, 0, 127, t.volume, 10, 5).setID(t.index + t.name);
			        }

			        fb.setChangeListener((element,value,form) -> {
			        	if(element.getId().equals("Vol")){
			        		volume = element.asInt();
			        		out.setGain(volume);
			        	}
			        	for(Track t: tracks){
			        		if(element.getId().equals(t.index+t.name)){
			        			t.volume = element.asInt();
			        		}
			        	}
			        });
			        fb.show();
					

				}}));

		JMenuItem itemControls = new JMenuItem("Controls");
		//MenuItem itemRecent = new MenuItem("Open Recent");

		helpm.add(itemControls);
		

		itemControls.addActionListener((new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent a) {
				new UiBooster().showInfoDialog("General Controls:\n   d: play/ speed up\n   s: stop/ reset speed\n   a: speed down\n   left: seek back\n   right: seek forward\n   scroll: zoom\n   shift+scroll: seek\n   ctrl+scroll: up/down piano roll\n   ctrl+shift+scroll: piano roll zoom\n" + 
					"   \n   1: arrow tool   2: tempo tool   3: pen tool   4: tap tool\n" +
					"\nArrow Tool:\n   left click: add note\n   right click: play/test note\n   left click and drag: control length\n" +
					"\nPen Tool:\n   left click: add note\n   right click: play/test note\n   left click and drag: control length\n" +
					"\nTap Tool:\n   t/y: add tap at play head\n   left click: add tap at mouse\n   Best use is tapping t to moments you hear in the music as is plays\n" +
					"\nTempo Tool:\n   t/y: add tap at play head\n   left click: add first goalpost\n   right click: add second goalpost\n   You'll want to tap like a metronome with t, and once it looks kinda close, the goalposts will extrapolate the tempo from just those two points\n" +
					"\nOther:\n   q: toggle quantize (snapping to the beats)\n   x: clears current track's notes or taps (based on tool)"
					);
			}}));

		frame.setVisible(true);
		
	}
}
		


class Note implements Comparable{
	Track track;
	int time;
	int endTime;
	int length;
	int pitch;

	float x,y,w,h;

	Note(Track track,int time, int pitch, int length){
		this.track = track;
		this.time = time;
		this.pitch = pitch;
		this.length = length;
		endTime = time+length;
	}
	Note(Track track, JSONObject notej){
		this.track = track;
		this.time = notej.getInt("time");
		this.pitch = notej.getInt("pitch");
		this.length = notej.getInt("length");
		endTime = time+length;
	}

	 public void updateDim(int s, int step){
		/* TODO
		if(this == chosen && noteHold){
			x += mouseX - pmouseX;
			y += mouseY - pmouseY;
			return;
		}
		*/
		x = (time*1.0f-s)/step;
		float row = (height*1.0f/rollZoom);
		y = (int)(-pitch + rollMid + (rollZoom/2))*row;
		w = length/step;
		h = row;
	}

	 public void reverseDim(int s, int step, boolean quantize){
		time = (int)(x*step+s);
		float off = (time - startTime )%(tempo/tempoDiv);
		time -= off;
		float row = (height*1.0f/rollZoom);
		pitch = (int)(-y/row + rollMid + (rollZoom/2));
	}

	 public void display(int s, int step, float hue, float trans){
		updateDim(s,step);

		fill(hue,100,255,trans/2);
		stroke(hue,100,255,trans);
		rect(x,y,w,h);
	}

	 public boolean touchingPoint(float inx, float iny, int s, int step){
		updateDim(s,step);

		return x <= inx && inx <= x+w && y <= iny && iny <= y+h;

	}

	 public int compareTo(Object o){
		int comp = time - ((Note)o).time;
		if(comp == 0){
			comp = pitch - ((Note)o).pitch;
		}
		return comp;
	}


	 public JSONObject toJ(){
		JSONObject out = new JSONObject();
		out.setInt("time",time);
		out.setInt("pitch",pitch);
		out.setInt("length",length);
		return out;
	}

}








 public void startSongPick(){
	state = LOAD_SONG;
	println(dataFile("..\\songs\\pick a song..."));
	selectInput("Select a song file:","songPick",dataFile("songs\\pick a song ..."));
	fill(255,40);
	rect(-1000,-1000,10000,10000);
}

 public void songPick(File f){
	WaitingDialog dialog = uib.showWaitingDialog("Starting", "Please wait",true);
	if(f == null){
		//selectInput("Select a song file:","songPick");
    	dialog.close();
		return;
	} else {
		try{
			fileName = f.getCanonicalPath();
		} catch(Exception e){
			//
		}
	}
	
	try{
		song2 = new FilePlayer(minim.loadFileStream(fileName));
	} catch (Exception e){
		uib.showErrorDialog("Failed to load\n" + fileName + "\n", "ERROR");
    	dialog.close();
	}

	sample = minim.loadSample(fileName,1024);
	input = minim.getLineIn();
	out = minim.getLineOut(minim.STEREO, 1024, sample.sampleRate());

	rate = new TickRate(1.0f);
	sig = sample.getChannel(AudioSample.LEFT);
	float[] tempSig = sample.getChannel(AudioSample.RIGHT);
	// add left and right channels to temp
	for(int i = 0; i < sig.length; i++){
		tempSig[i] = max(sig[i],tempSig[i]);
	}
    dialog.setMessage("Ready");
    dialog.close();
	// blur temp into sig
	int range = 0; // how many steps to the left and right of current pos you go
	float tot = 0;
	/*
	for(int j = 0; j <= range*2; j++){
		tot += pow(tempSig[j], .5) * (1.0/(range*2+1));
	}
	*/
	for(int i = range; i < sig.length - range-1; i++){
		/*
		if(tempSig[i] < 0){
			sig[i] = -pow(-tempSig[i],.5);
		} else {
			sig[i] = pow(tempSig[i],.5);
		}
		*/
		sig[i] = tempSig[i];
		
		//tot += pow(tempSig[i+range+1],.5) * (1.0/(range*2+1));
		//tot -= pow(tempSig[i-range],.5) * (1.0/(range*2+1));
	}
	tracks.add(new Track("Master",0));

	song2.patch(rate).patch(out);
	rate.setInterpolation(true);

	println(out.hasControl(Controller.VOLUME));
	println(out.hasControl(Controller.GAIN));
	out.setGain(volume);

	
	int ind = fileName.lastIndexOf('\\');
	if(ind == -1){
		ind = fileName.lastIndexOf('/');
		if(ind != -1){
			saveName = dataPath("")+"/saves/"
			+ fileName.substring(fileName.lastIndexOf('/'),fileName.lastIndexOf('.'))
			+ "SAVE.json";
		} else {
			saveName = "";
		}
	} else {
		saveName = dataPath("")+"\\saves\\"
		+ fileName.substring(fileName.lastIndexOf('\\'),fileName.lastIndexOf('.'))
		+ "SAVE.json";
	}

	File temp = new File(saveName);
	if(temp.exists()){
		uib.showConfirmDialog(
	        "We detected save data! Load it?",
	        "Load Save",
	        () -> loadFile(temp),
	        () -> state = EDIT);
	}
	state = EDIT;
}

 public void startSaveFile(){
	if(state != EXIT){
		state = SAVE;
	}
	selectOutput("Choose save file:","saveFile");
	fill(255,40);
	rect(-1000,-1000,10000,10000);
}

 public void startLoadFile(){
	state = LOAD_SAVE;
	selectInput("Choose file to load:","loadFile");
	fill(255,40);
	rect(-1000,-1000,10000,10000);
}

 public void loadFile(File f){
	state = EDIT;
	if(f == null){
		return;
	}
	JSONObject json;
	String uh = "";
	try{
		uh = f.getCanonicalPath();
		json = loadJSONObject(uh);
	}catch(Exception e){return;}

	fileName = json.getString("filePath");
	// TODO load song if no song loaded
	saveName = uh;

	tool = json.getInt("tool");
	trackInd = json.getInt("trackInd");

	JSONArray quanj = json.getJSONArray("quan");
	for(int i = 0; i < quanj.size(); i++){
		quan[i] = quanj.getBoolean(i);
	}

	JSONObject tempoj = json.getJSONObject("tempo");
	tempo = tempoj.getFloat("tempo");
	startTime = tempoj.getFloat("startTime");
	tgate1 = tempoj.getInt("tgate1");
	tgate1s = tempoj.getFloat("tgate1s");
	tgate2 = tempoj.getInt("tgate2");
	tgate2s = tempoj.getFloat("tgate2s");
	tempoSet = tempoj.getBoolean("tempoSet");
	tempoDiv = tempoj.getInt("tempoDiv");

	JSONArray tracksj = json.getJSONArray("tracks");

	tracks.clear();
	for(int i = 0; i < tracksj.size(); i++){
		tracks.add(new Track(tracksj.getJSONObject(i),i));
	}
}

 public void saveFile(){
	saveFile(new File(saveName));
}

 public void saveFile(File f){
	if(f == null){
		if(state == EXIT){
			exitActual();
		}
		state = EDIT;
		return;
	}
	JSONObject json = new JSONObject();
	json.setString("filePath",fileName);
	json.setInt("tool",tool);
	json.setInt("trackInd",trackInd);

	JSONArray quanj = new JSONArray();
	for(int i = 0; i < quan.length; i++){
		quanj.setBoolean(i,quan[i]);
	}
	json.setJSONArray("quan",quanj);

	JSONObject tempoj = new JSONObject();
	tempoj.setFloat("tempo",tempo);
	tempoj.setFloat("startTime",startTime);
	tempoj.setInt("tgate1",tgate1);
	tempoj.setFloat("tgate1s",tgate1s);
	tempoj.setInt("tgate2",tgate2);
	tempoj.setFloat("tgate2s",tgate2s);
	tempoj.setBoolean("tempoSet",tempoSet);
	tempoj.setInt("tempoDiv",tempoDiv);
	json.setJSONObject("tempo",tempoj);

	JSONArray tracksj = new JSONArray();
	for(int i = 0; i < tracks.size(); i++){
		tracksj.setJSONObject(i,tracks.get(i).toJ());
	}
	json.setJSONArray("tracks",tracksj);

	try{
		saveJSONObject(json, f.getCanonicalPath());
		saveName = f.getCanonicalPath();
	}catch(Exception e){}

	if(state == EXIT){
		exitActual();
	}
	state = EDIT;
}

Note checks = new Note(null,0,0,0);
Note checklast = new Note(null,0,0,0);

int START = 1;
int STOPS = 2;

class Track{
	int index;
	String name;
	TreeSet<Note> notes;
	TreeSet<Note> stops;
	float hue;
	TreeSet<Integer> taps;
	int instrument;
	int volume = 60;


	Track(int i){
		index = i;
		name = "Track "+i;
		notes = new TreeSet<Note>();
		stops = new TreeSet<Note>(new Comparator<Note>(){
			 public int compare(Note a, Note b){
				int comp = a.endTime - b.endTime;
				if(comp == 0){
					comp = a.pitch - b.pitch;
				}
				return comp;
			}
		});
		taps = new TreeSet<Integer>();
		hue = random(0,255);
		channels[index].programChange(192+index,0);
	}
	Track(String name, int i){
		index = i;
		this.name = name;
		notes = new TreeSet<Note>();
		stops = new TreeSet<Note>(new Comparator<Note>(){
			 public int compare(Note a, Note b){
				int comp = a.endTime - b.endTime;
				if(comp == 0){
					comp = a.pitch - b.pitch;
				}
				return comp;
			}
		});
		taps = new TreeSet<Integer>();
		hue = random(0,255);
		channels[index].programChange(192+index,0);
	}
	Track(JSONObject trackj, int ind){

		index = ind;
		notes = new TreeSet<Note>();
		stops = new TreeSet<Note>(new Comparator<Note>(){
			 public int compare(Note a, Note b){
				int comp = a.endTime - b.endTime;
				if(comp == 0){
					comp = a.pitch - b.pitch;
				}
				return comp;
			}
		});
		taps = new TreeSet<Integer>();

		name = trackj.getString("name");
		hue = trackj.getFloat("hue");
		instrument = trackj.getInt("instrument");

		JSONArray notesj = trackj.getJSONArray("notes");
		for(int i = 0; i < notesj.size(); i++){
			Note j = new Note(this,notesj.getJSONObject(i));
			notes.add(j);
			stops.add(j);
		}
		JSONArray tapsj = trackj.getJSONArray("taps");
		for(int i = 0; i < tapsj.size(); i++){
			taps.add(tapsj.getInt(i));
		}
		channels[index].programChange(192+index,instrument); // TODO
	}

	 public void setInstrument(int i){
		channels[index].programChange(192+index,i);
	}

	 public void setNoteLength(Note n, int length){
		notes.remove(n);
		stops.remove(n);
		n.length = length;
		notes.add(n);
		notes.add(n);
	}

	 public void clearNotes(){
		notes.clear();
		stops.clear();
	}

	 public void clearTaps(){
		taps.clear();
	}

	 public Note addNoteX(int x, int pitch, int length, boolean quantize){
		return addNote(s() + (x-width/2)*step(),pitch,length, quantize);
	}

	 public Note addNote(int time, int pitch, int length, boolean quantize){
		if(quantize){
			float off = (time - startTime )%(tempo/tempoDiv);
			time -= off;
		}
		if(length == -1){
			length = (int)(tempo/tempoDiv);
		}
		Note n = new Note(this,time,pitch,length);
		if(!notes.add(n)){
			notes.remove(n);
			stops.remove(n);
		} else {
			stops.add(n);
		}
		return n;
	}

	 public void removeNote(Note n){
		notes.remove(n);
		stops.remove(n);
	}

	 public void addTapX(int x, boolean quantize){
		addTap(s() + (x-width/2)*step(), quantize);
	}

	 public void addTap(int time, boolean quantize){
		if(quantize){
			float off = (time - startTime + (tempo/tempoDiv)/2)%(tempo/tempoDiv) - (tempo/tempoDiv)/2;
			time -= off;
		}
		taps.add(time);
	}

	 public void display(int s, int step){
		if(notes.size() != stops.size()){
			println(notes.size() + " " +stops.size());
		}
		float trans = 100;
		if(index == trackInd){
			trans = 230;
		}
		for(int tap: taps){
			float x = (tap*1.0f-s)/step;
			stroke(hue,255,255,trans);
			line(x,0,x,height);
		}
		for(Note n: notes){
			n.display(s,step,hue,trans);
		}
	}

	 public SortedSet<?> getWindowX(int x, int x2, int from){
		float s = s() + step()*(x-width/2);
		float lastS = s() + step()*(x2-width/2);
		return getWindow(s,lastS,from);
	}

	 public SortedSet<?> getWindow(float s, float lastS, int from){
		SortedSet<?> out;

		TreeSet<?> general;
		if(from == START){
			checks.time = (int)(s);
			checklast.time = (int)(lastS);
			general = notes;
		} else if(from == STOPS){
			checks.endTime = (int)(s);
			checklast.endTime = (int)(lastS);
			general = stops;
		} else if(from == TAP){
			general = taps;
		} else {
			//TODO error
			return null;
		}

		if(from == START || from == STOPS){
			if(s < lastS){
				out = (SortedSet<Note>) new TreeSet<Note>();
			} else {
				out = ((TreeSet<Note>)general).subSet(checklast,true,checks,true);
			}
		} else if (from == TAP){
			if(s - lastS < 0){
				out = (SortedSet<Integer>) new TreeSet<Integer>();
			} else {
				out = ((TreeSet<Integer>)general).subSet((int)lastS,true,(int)s,true);
			}
		} else {
			out = (SortedSet<Integer>) new TreeSet<Integer>();
		}
			
		return out;
		
		
	}

	 public JSONObject toJ(){
		JSONObject out = new JSONObject();

		out.setString("name",name);
		out.setFloat("hue",hue);
		out.setInt("instrument",instrument);

		JSONArray notesj = new JSONArray();
		int i = 0;
		for(Note n: notes){
			notesj.setJSONObject(i,n.toJ());
			i++;
		}
		out.setJSONArray("notes",notesj);

		JSONArray tapsj = new JSONArray();
		i = 0;
		for(Integer t: taps){
			tapsj.setInt(i,t);
			i++;
		}
		out.setJSONArray("taps",tapsj);


		return out;
	}

}


  public void settings() { size(1200, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TunePad" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
